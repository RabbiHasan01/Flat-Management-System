\section{Normalization}\label{sec:norm}
%From your Relational model, find the functional dependencies of each relation schema and show that they are normalized upto 3NF or BCNF.%
Normalization is a process of avoiding as possible redundancy from a relation or a set of relational table . Redundancy may occur many problems like \begin{enumerate}
\item Insertion anomalies
\item Deletion anomalies and 
\item Updating anomalies.
\end{enumerate}
\\
 
\noindent  
\textbf{Insertion anomalies : }An insertion anomaly is the unability to add data to the database due to the absence of other data . Suppose,a new  Flat-ID is inserted into flat-Info table but won't insert  data under the tuple then the data is made inconsistencies due to omission in database.\\

\noindent
\textbf{Deletion anomalies : }A deletion anomaly occurs when you delete a record that may contain attributes that shouldn’t be deleted. For instance,if we delete an record in an attributes , we will have a chance to loss  other attributes information in  a corresponding table .\\
\noindent
\textbf{Updating anomalies : }An update anomaly is a data inconsistency that results from data redundancy and a partial update .
\\
So,normalization  helps to eliminate this type problem and  makes it easier  to retrieve data.

\subsection{First Normal Form(1NF)}
"A relation does not contain any multi-valued attributes and composite attributes." In first normalization,
\begin{enumerate}
\item There are only Single Valued Attributes.
\item Attribute Domain does not change
\item There is a unique name for every Attribute/Column.
\item The order in which data is stored does not matter.
\end{enumerate}
 
\\
\noindent
 \textbf{Multi-valued attributes} : A multi-valued attribute of an entity is an attribute that can have more than one value associated with the key of the entity. For example , a large company can have many divisions, some of them possibly in different cities.
 \\
\noindent 
\textbf{Composite attributes} : An attribute composed of many other attributes is called as composite attribute.
 \\
 
 \subsection{Second Normal Form(2NF)}
 Second Normal Form (2NF) is based on the concept of full functional dependency . Second Normal Form applies to relations with composite keys , that is, relations with a primary key composed of two or more attributes . A relation with a single-attribute primary key is automatically in at least 2NF .
 In second normal form
 \begin{enumerate}
     \item It must be 1st normal form and
     \item There must be no  partial dependency .
\end{enumerate}
\noindent     
 \textbf{Partial Dependency : }If the proper subset of candidate key determines non-prime attribute, it is called partial dependency\footnote{src-geekforgeek.com/....}.
  
 \subsection{Third Normal Form(3NF)}
 A relation is in third normal form , if there is no transitive dependency for non-prime attributes as well as it is in second normal form .
A relation is in 3NF\footnote{3NF:For each FDs,LHS must be CK/SK OR RHS is a prime attributes }. if at least one of the following A→B:
  \begin{enumerate}
  
 \item It must be 2NF.
 \item There must not be any transitivity and
\item A→B is trivial where $ A \subset R and B \subset R $.
\end{enumerate}
 \\
 \textbf{Transitivity : } If A→B and B→C are two functional dependencies  ,then A→C is called transitive dependency/transitivity . 
 \\
\subsection{Boyce-Codd Normal Form(BCNF) : }
Boyce–Codd Normal Form (BCNF) is based on functional dependencies that take into account all candidate keys in a relation; however, BCNF also has additional constraints compared with the general definition of 3NF.\\
In BCNF:
\begin{enumerate}
\item It must be 3NF .
\item A→B is trivial where$ A \subset R and B \subset R $ . and
\item There must be a super key(SK).
  
\end{enumerate}
\section{Normalization: in the context of project}\label{sec:ncp}
\textbf{KEYS : }
Keys in DBMS is an attribute or set of attributes which helps to identify a row(tuple) in a relation . They allow   to find the relation between two tables . Keys help   uniquely identify a row in a table by a combination of one or more columns in that table . Key is also helpful for finding unique record or row from the table . Database key is also helpful for finding unique record or row from the table.
\begin{enumerate}
 
\item
\textbf{Super Key : }A super key is a group of single or multiple keys which identifies rows in a table.\\
 
\item
\textbf{Primary Key : }A Primary key is a column or group of columns in a table that uniquely identify every row in that table.\\
 
\item
\textbf{Candidate Key : }A Candidate key is a set of attributes that uniquely identify tuples in a table. Candidate Key is a super key with no repeated attributes .\\
\item
\textbf{Alternate Key : } An Alternative key is a column or group of columns in a table that uniquely identify every row in that table.\\
\item
\textbf{Foreign Key : }A Foreign Key is a column that creates a relationship between two tables. The purpose of Foreign keys is to maintain data integrity and allow navigation between two different instances of an entity .\\
\item
\textbf{Compound Key : }A Compound key has two or more attributes that allow you to uniquely recognize a specific record. It is possible that each column may not be unique by itself within the database .\\
\item
\textbf{Prime Attribute : }A prime attribute of the database tables which are candidate keys of the database tables are called prime attributes.\\
\newpage
\item
\textbf{Functional Dependency :}
A functional dependency is a constraint that specifies the relationship between two sets of attributes where one set can accurately determine the value of other sets. It is denoted as X → Y, where X is a set of attributes that is capable of determining the value of Y. The attribute set on the left side of the arrow, X is called Determinant, while on the right side, Y is called the Dependent.

\end{enumerate}
\textbf{Table:User/SignUp}\\
User\{ \underline{userID} , email, username , phoneNo
, name , password , date , roleID , address. \}\\
\newline
Functional Dependency :F\textsuperscript{+} clouser
\begin{enumerate}
\item
\{userID\}→\{username , email , phoneNo , name , date , address.\}\\
\end{enumerate}
Candidate Key : userID..\\
Prime Attribute : userID.\\
Non prime Attribute:email,phoneNO username , name , password , date , roleID , address.\\
Foreign Key : roleID.\\
 
\begin{enumerate}

\item No multi-valued/composite attributes,So it's 1NF.
\item  There is no partial dependency,So it's 2NF.
\item Here,the right side attributes userID is super keys and there is no transitivity/transitive dependency,So it's 3NF.\\
\end{enumerate}\\

\newpage
\noindent
\textbf{Table : FlatInfo}\\
FlatInfo\{\underline{flatID} , owner , type , floor , room , facilitiesID ,address\}\\
\newline
Functional Dependency :F\textsuperscript{+} clouser
\begin{enumerate}
\item 
 
\{flatID\}→\{owner , type , floor , room , facilitiesID , address\}\\
\end{enumerate}
Candidate Key : flatID\\
Prime Attribute : flatID\\
Non prime Attribute : owner , type , floor , room , facilitiesID , address\\
Foreign Key : facilitiesID\\
\begin{enumerate}
\item No multi-valued/composite attributes,So it's 1NF.
\item Single Primary Key and no partial dependency,So it's 2NF.
\item There is no transitivity,So it's 3NF.\\
\end{enumerate}
 
\noindent 
\textbf{Table:LogInfo}\\
LogIn\{\underline{logID} , userID ,ipAddress , browser , OS , password , data\}\\
\newline
Functional Dependency : F\textsuperscript{+} clouser
\begin{enumerate}
\item 
 
\{logID\}→\{userID , ipAddress , browser , OS , password , data\}
\end{enumerate}
Candidate Key: logID\\
Prime Attribute : logID\\
Non Prime Attribute : userID , ipAddress , browser , OS , password , data\\
Foreign Key:userID\\
 
\begin{enumerate}
\item No multivalued/composite attributes,So it's 1NF.
\item Single Primary Key and no partial dependency,So it's 2NF.
\item There is no transitive dependency,So it's 3NF.\\
\end{enumerate}

\newpage
\noindent
\textbf{Table:UserRole}\\
UserRole(\underline{roleID},role\textunderscore{name})\\
\newline
Functional Dependency : F\textsuperscript{+} clouser 
\begin{enumerate}
\item 
\{roleID\}→\{role\textunderscore{name}\}
\end{enumerate}
Primary Key : roleID\\
Prime Attribute : roleID\\
Non Prime Attribute : role\textunderscore{name}\\
\begin{enumerate}
\item No multivalued/composite attributes,So it's 1NF.
\item Single Primary Key and no partial dependency,So it's 2NF.
\item There is no transitive dependency,So it's 3NF.\\
\end{enumerate}

\noindent
\textbf{Table:Facility }\\
Facility\{\underline{facilitiesID},wifi,AC,gas\}\\
\newline
Functional Dependency : F\textsuperscript{+} clouser
\begin{enumerate}

\item 
\{facilitiesID\}→\{wifi , AC , gas\}
\end{enumerate}
Candidate Key/Primary Key : facilitiesID\\
Prime Attribute : facilitiesID\\
Non Prime Attribute : wifi , AC , gas\\
\begin{enumerate}
\item No multivalued/composite attributes,So it's 1NF.
\item Single Primary Key and no partial dependency,So it's 2NF.
\item There is no transitive dependency,So it's 3NF.\\
\end{enumerate}
\newpage
\noindent
\textbf{Table : BookingInfo }\\
BookingInfo\{BookID , userID , bookDate , flatID , isBooked , reqDate\}\\
\newline
Functional Dependency:F\textsuperscript{+} clouser
\begin{enumerate}
 \item 
 
\{bookID\}→\{userID , bookDate , flatID , isBooked ,reqDate\}
\end{enumerate}
Candidate Key : BookID\\
Foreign Key/Primary Key: flatID\\
Prime Attribute: BookID\\
Non Prime Attribute: userID , bookDate , flatID , isBooked , reqDate.
\begin{enumerate}
\item No multi-valued/composite attributes,So it's 1NF
\item Single Primary Key and no partial dependency,So it's 2NF.
\item There is no transitive dependency,So it's 3NF.\\
\end{enumerate}










\clearpage